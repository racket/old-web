This directory contains the OLD sources for the PLT web sites.

The rest of this text is the original documentation.  It is old and
outdated, and the whole thing will soon disappear.

-------------------------------------------------------------------------------
The structure of this directory is as follows:

  * build.ss
    The main script that generates all content.

  * common
    Scheme sources that implement the HTML generation.

  * www, download, bugs, internal, cgi-bin, mail
    Sources for the web content.  Source directories correspond to output
    directories.

  * packages
    Content for PLT packages, generates output in www/software/.

  * pre-release
    Skeleton content for the nightly build script -- these files contain holes
    that are filled by the script.

  * search
    search-related materials (for the Google search gadget)

-------------------------------------------------------------------------------
Creating the pages

To create the pages, run the build.ss script at the top level.  This script
should be used in an empty directory, where output files will be placed.  For
each content directory you will get a directory holding that content.  The
general idea is that once you have this content you can package it up and copy
it over to the actual servers.  For various reasons, the generated HTML content
does not use relative URLs (for example, www.plt-scheme.org/software/drscheme
is also used at drscheme.org using a symbolic link).

To try out modifications, run the script from a directory that is available
from a web server and use `--root' to specify a different root mapping: for
example, if the directory is visible at http://foo.org/bar, then run

  .../build.ss --root http://foo.org/bar

Alternatively, use `--here' which will use `file://...current-path...' as a
root.

There will be a few symbolic links that will point to non-existent places.
There are links that should be created on the servers to content that is not
generated by this script.  IMPORTANT: to add new content that is made of simple
files, simply add it to the content directories -- all non-.ss files will be
copied to the output directory.  Content that cannot be added should be
incorporated as a symbolic link to a place on the server where that content is
available.  Currently, this is the way that the download server accesses the
download bundles, the documentation trees, and the the pre-release directory,
and the main server has such a link to the web-version of the DrScheme tour.

-------------------------------------------------------------------------------
Configuration

"common/conf.ss" contains common configuration settings that are expected to
change more frequently.  Also there are some HTML snippets in
"common/misc-html.ss".  The layout is constructed by code in "common/layout.ss"
which is more difficult to modify, but it is not expected to change frequently.

-------------------------------------------------------------------------------
Directory layout

In general, the source directory structure in the content directories
corresponds to the output structure, which correspond to the actual HTML.  An
immediate benefit of this is that if you want to change some content, knowing
which page generates that content is easy -- for example, to change
"http://www.plt-scheme.org/foo/bar.html" you should look for one of these
files:

  * "www/foo/bar.html" (copied if it exists)
  * "www/foo/bar.ss"   (generates "bar.html")
  * "www/foo/index.ss" (might generate a "bar.html" sub-page)

Exactly one of these should exist -- the build script will abort if there is an
attempt to overwrite a file.  It is intentionally difficult to have a Scheme
file that creates output in a different directory, as this can lead to
administrative mess where `grep' is the only way to find the code you want to
change.

The only exception for this is the mapping between source and output
directories.  This is defined as the `default-mappings' binding in
"common/conf.ss" which defines mappings between source directories and output
URLs and directories.  This list is modified when the `--root' or `--here'
command-line arguments are used.  This list can be used to refer to some links
by different paths -- for example, it maps "/packages" to "/www/software"
(actually it uses "packages" that also marks the directory as a top-level
content directory).  These mappings should be modified only when the physical
layout of the web content changes.

-------------------------------------------------------------------------------
Content generating file -- low level interface

Files in content directories are divided into three groups:

1. Some patterns are ignored, currently this includes ".*", "CVS", and "*~".

2. Scheme source files (.ss) are executed as described below.

3. All other files are copied over to the output directories.

Scheme source files in content directories should be modules.  These files are
output generators if they provide a `run' binding, which is expected to be a
nullary procedure that will be invoked to create the content.  If a Scheme file
does not provide `run', it is skipped.

In general, a `run' procedure can do whatever it wants -- it will be executed
in the appropriate output directory where it can create files freely.  There
are certain conventions that should be followed though:

1. Do not create files outside of the current directory (as discussed in the
   previous section).

2. If you're creating HTML content (usually using Xexeprs), use `url' when you
   refer to other pages.  This for two reasons: (a) it will convert relative
   links to absolute URLs, (b) relative links that are referred to will be
   checked when the build is done, and an error will be signaled if an
   uncreated page was referred to.

   For example, you can use
   * (url "foo.html") to refer to a file this directory
   * (url "../foo.html"), (url "bar/foo.html") for relative files
   * (url "/www/foo.html") for absolute files related to other generated
     content
   * (url 'symbol) for a few symbolic links (included in the `symlinks' list in
     "common/conf.ss")
   * (url "http://foo.bar.com/") will simply return its value -- this makes it
     possible to treat local and external links in a uniform way.

3. Before you write a file, use `(writing "output-file")' -- this will let the
   system know this file exists for usages of `url', and it will signal an
   error if the file was already (marked as) generated.

4. These files also serve as a kind of information registries which can make
   some information available to other code.  There are functions that access
   this information, for example `link-to' will search the file that implements
   the target file for a `title' binding.

5. To create additional files in the current directory, a file can provide a
   `sub-pages' binding that serves as a table that matches file names to some
   list of bindings.  If this `sub-pages' is provided, it will be scanned and
   each entry will be treated as a page, and a `run' binding will be executed.
   (Sub-pages cannot contain nested `sub-pages'.)  "common/begin-page.ss"
   provides a `begin-page' form that makes a definition context that will be
   added to to `sub-pages' in the right way.

The high-level interface that is described below makes these things easier.

-------------------------------------------------------------------------------
Content generating file -- high level interface

In general, all Scheme content file should begin with

  #reader".../common/html-script.ss"

which will do several things that make it easy to write these files:

1. The content of the file is automatically wrapped in an appropriate `module'
   form.

2. All necessary functionality from modules in the common directory will be
   required.

3. All definitions are provided.

4. `this-html-name' will be bound to the default html-file name (the same file
   name with a ".html" suffix), `this-web-dir' will be bound to the current web
   directory, `this-build-dir' will be bound to the corresponding filesystem
   output directory.

5. A syntactic extension that makes it easy to generate Xexpers will be used.
   This extension is implemented in "common/reader.ss", described below.

See below for additional information, organized by files in "common".  The two
important parts that make the high-level interface are the syntactic extensions
in "common/reader.ss" for writing content, and "common/layout.ss" for
organizing things into web pages.

-------------------------------------------------------------------------------
common/conf.ss

> default-mappings

  A list of source-target mappings which is used with `set-mappings!' from
  "paths.ss".  Each item is a list of a source and its map.

  * if the source does not begin with a "/", it specifies a top-level directory
    that will be processed when building the pages

  * if the mapped path is a url, it is used when creating urls through the
    `url' function

  * otherwise the mapped path is used to map a source path to a web path and
    another mapping is attempted -- so it can also map web paths to different
    web paths; it is also used before `url' maps to a url.

  * mappings are tried in order

  * mappings should be 1:1 for reverse mapping of web-path to source path

> hubs

  A list of hub entries that appear at the top of tall-pages and the bottom of
  the navigation side of panel pages.  Each is a title (Xexpr) and its target
  path/url, the path/url can be `#f', which will just put the title in.

> ignored-files

  A regular expression for filenames that are skipped in the build ("CVS" and
  names that begin with a "." or end with a "~").

> ftp-dir

  The directory on the download server where "bundles", "patches", and "doc"
  can be found.  This is an ftp directory since it is used by mirror sites.

> page-icon

  The web-path of the icon file (.ico) that is used in all pages.

> default-color
> default-size

  Default color name for generated pages, and default icon size.  When icons
  are generated for this color and/or size, it will not be used as part of the
  generated name, so we always get a `plt-web.jpg' and `plt-web-med.jpg' icons.

> pre-release-color

  Color name for pre-release pages.

> colors

  A table that defines color names -- each entry is a list of a symbol that
  names the symbol and three rgb byte values.

> color-dim-factor
> color-bright-factor

  Factors that multiply an RGB color to get to a dimmed or a bright version of
  the same color.  The bright factor is used with the amount that is subtracted
  from 255, so it is also smaller than one.

> icon-scales

  A table of scales that specifies how the original plt-logo image is reduced
  to generate icons of various sizes.

> icon-location

  The web-path where icons are placed.

> source-image-dir
> announcements-file

  The paths of the source icon images and the announcements file, relative to
  the top-level source directory.

> symlinks

  A list of `symbolic links' -- these are symbols that are used as convenient
  shortcuts to given locations.  Each element is a list of a symbol, an
  optional title, and a target.  The target can be a generated web path or a
  full url.  The title can be specified as a string or an Xexpr, if it is
  missing, it will be pulled out of the source file's `title' binding.

> gradients?
> gradient-bg

  Random things for fun effects.

-------------------------------------------------------------------------------
common/misc-html.ss

> (PLT title)
> (PLT: title)

  Return "PLT <title>" and "PLT Scheme: <title>" respectively.

> windows-versions

  A string that holds a description of the Windows versions PLT Scheme can work
  with.


> (system-requirements body ...)

  Returns a paragraph Xexpr with a "System Requirements:" title.

> (standard-support)

  Returns an Xexpr for a standard support page.

> (standard-learning drscheme?)

  Returns an Xexpr for a standard learning page.  If `drscheme?' is #t, the
  page will contain a link to the DrScheme page.

> planet-desc
> cookbook-desc

  A list of strings that describe PLaneT and the Scheme cookbook respectively.

-------------------------------------------------------------------------------
common/utils.ss

> (define* id expr)
> (define* (id . args) expr)

  Same as `define', and `provide's the `id'.

> (eprintf fmt args ...)

  Same as `printf' but uses `current-error-port' for output.

> (->string x)

  Converts paths, symbols, and numbers to a string.

> (concat arg ...)

  Concatenates a bunch of things to a single string (`string-append' used with
  `->string')

> (mappend f l ...)

  Same as `map' but applies `append' on the result.

> (map/sep f sep l ...)
> (mappend/sep f sep l ...)

  Same as `map' and `mappend', but puts `sep' between the elements of the
  result.  For example

    > (apply concat (map/sep PLT ", " '("foo" "bar" "baz")))
    "PLT foo, PLT bar, PLT baz"

> (ss->html str)
> (html->ss str)

  Converts "foo.ss" to "foo.html" and back.

> (dir [path])

  Same as `directory-list', but blind to names that match `ignored-files', and
  returns a list of strings.

> (dirname path)
> (basename path)
> (split-path* path)

  Returns the directory part, the name part, or both of a given path.  Both
  input and output(s) are strings.

> (simplify-path* path)

  Similar to `simplify-path' but works on strings.

> (url-string? str)

  True if `str' is a URL string (begins with "foo://").

> (dynamic-require* file sym [default-thunk])

  Similar to `dynamic-require', but has an optional failure thunk.

> (add-exit-hook thunk)
> (run-exit-hooks)

  Adds an exit hook, and runs all exit hooks.  Used to add consistency
  checkers.

> (warn fmt args ...)
> warnings?

  A function that prints a warning, and a parameter that indicates whether
  `warn' was used.  The exit hooks are all run, and using the parameter an
  error is signaled if there were any warnings (this makes it possible to use
  in scripts, and also to show all warnings when trying things).

-------------------------------------------------------------------------------
common/html-xexprs.ss

This defines functions that generate Xepxrs, making it easier to write
Xexpr-generating code.  Each such function simply returns the matching Xexpr.
For example,

  (b "foo" "bar") -> (b () "foo" "bar")

To deal with attributes, this module provides certain `foo:' bindings.  These
are special values that are detected by these Xepxr constructors and turned
into an attribute list (and non-string values are converted to strings):

  (b style: 'blah "foo" "bar") -> (b ((style "blah")) "foo" "bar")

Also, `nbsp' and `mdash' are bound to the matching symbols, which makes it easy
to use in code without quoting.

Finally, a `splice' procedure is provided.  Using it returns a special value
that will make its arguments spliced into a containing xexpr constructor.

This module should be extended whenever new HTML tags or attribute names are
used.

-------------------------------------------------------------------------------
common/html-script.ss

This module defines a syntax reader that should be used by all content
generator scripts: it provides all necessary definitions, defines a few useful
things, and requires all functionality in "common" (except for
"common/build.ss") as well as useful standard libraries ("list.ss" and
"etc.ss").  It is based on the Scribble syntax, to handle text.

-------------------------------------------------------------------------------
common/paths.ss

> build-dir

  A parameter that holds the current (FS) build root directory.

> source-dir

  The source root directory (a string, not a parameter).

> current-web-dir (make-parameter #f)

  The path that corresponds to the currently executing file.

> top-dirs

  A list of the top-level source directory names.

> (set-simple-mappings! prefix)

  Sets a new mapping that makes all top-level directories map to directories at
  the given prefix URL.  Uses `default-mappings' to create the new mappings.

> (with-converted-dir /path thunk)

  Runs `thunk' in the dynamic context of the given `/path', which should be an
  absolute path.  The path can be a source path or a web-path -- it is mapped
  to a web-path using the current mappings.  To create the dynamic context, the
  corresponding output directory is created, and `thunk' is executed when
  `current-directory' is in the target directory, and `current-web-dir' is set
  to the current web-path.

> (run-file file)

  This function executes a Scheme source file -- it will check it for a `run'
  binding and executes one if found, and will also check it for defined
  sub-pages with `run' bindings which will be executed one by one.  The whole
  thing should be called in the appropriate dynamic context, such as the one
  established by `with-converted-dir'.  (This is done automatically by the scan
  in "common/build.ss".)

> (install-file file)

  This function is used with files other than Scheme sources, and will copy the
  file to the output directory.  Like `run-file', it should be used in the
  appropriate dynamic context.

> (write-string-to-file file string)

  The basic function that writes a string content into a file.  It is used to
  implement other higher level layers that use Xexprs.  The file is marked as
  written using `writing' (see below).

> (create-fileline from to)

  This creates a symbolic link under the given `from' name, to the `to'
  destination (which is usually a path that exists on a server machine).

> (create-dirlink from to)

  Similar to `create-filelink', except that it marks the whole tree under
  `from' as things that are considered written, so referring to stuff anywhere
  in there will not lead to warnings.  For example, it is used to establish the
  `bundles' link on the download server, and marks all URLs that point into
  this tree as safe.

> (absolute-path path)

  Converts a given path to an absolute one:
  * if `path' is a symbol, it is left as is (symbolic paths should always be
    absolute)
  * if it is a URL or if it begins with a "/" then it is left as is
  * otherwise, it is resolved as relative to the `current-web-dir' context
    (using `simplify-path*').

> (url /path)

  This should be the main tool for creating URL references.  Depending on the
  input `/path' it will behave as follows:
  * if it is a symbol, it is looked up in the `symlinks' table
  * if it is a url, it is used as is
  * otherwise it is made absolute with `absolute-path', converted to a web-path
    using the current mappings in effect, and will use a ".../" suffix for
    index files (unless we're using a "file://" as the root URL which will use
    ".../index.html".  (The translation process uses `path' mappings when it
    computes the absolute path, the `url' mappings to compute the actual URL.)

  In addition, it will mark the path as referenced, and when the build is done
  it will check that this path was created, showing a warning and throwing an
  error if not.  (There is an optional `noref?' argument that disables this,
  but this should not be used by code outside of "common/build.ss".)

> (get-page-binding path symbol/s [default])

  This function is used to pull out bindings from other page generator files.
  The given path is a relative path that will be translated back to a source
  path, the source file is then located and dynamic-require is used to extract
  the value from the file.
  * Translating the path is done by using reverse mappings, and a ".html"
    suffix will be converted to ".ss" -- the bottom line is that you can use
    either web-paths or source paths (possibly relative) to specify the file.
  * If a Scheme source file is not found, and if there is an "index.ss" file in
    that directory, it will search it for a corresponding sub-page set of
    bindings.  (Remember that each output file is generated by exactly one
    source file, so it is not be possible to have both "foo.ss" and an
    "index.ss" that has a "foo.html" subpage.)
  * Instead of a single symbol, you can use a list which will be tried one by
    one in order.  For example, the site-map page uses `(sitemap-title title)',
    which will use `title' only if there is no `sitemap-title'.
  * Finally, if no binding is found and a default value is given, it will be
    returned -- but if the file (or a sub-page) is not found you will get an
    error.

> (import-from path id ...)

  This is a syntax that uses `get-page-binding' to get a value, and bind it to
  the same name in the current file.  This is useful in cases where some piece
  of information in one page is used in other related pages, for example, a
  panel object is constructed in its main page and a different file that is
  linked from the panel will import its `panel' value.

> (link-to path #:key names label)

  This combines `url' and `get-page-binding' -- it will generate an `a' Xexpr
  with the right `href' attribute, and the text of the link will be the
  `link-title' or the `link' binding of the generating file.  `names' can be
  given to use other binding names, and `label' specifies a "#<label>" suffix
  for the URL.  If a symbol is used instead of a `/path', the `symlinks' table
  is used (see above) -- the symbol is looked up, and if it has only a target
  path but no title, then the title is retrieved from the source.

> (blurb-of path)

  Uses `get-page-binding' to get the value of `blurb'.

> (writing path)
> (writing/prefix prefix)

  `writing' will mark the given `path' as written, so that referring to it will
  not signal any warnings.  It should be used whenever a file is generated.
  (If you use `install-file', `write-string-to-file', or the usual functions
  from "common/layout.ss", then there is no need to do this.)  `writing/prefix'
  is similar, except that all references with the given prefix are considered
  fine, `create-dirlink' uses it to mark everything in the directory link.

-------------------------------------------------------------------------------
common/begin-page.ss

> (begin-page filename definition ... expr ...)

  Wraps the definitions and expressions in a `let' context that rebinds
  `this-html-name', then associates the list of bindings with the given
  filename in the current `sub-pages' value.  Use this to define sub-pages,
  instead of playing with the `sub-pages' binding directly.

  Use simple filenames, not paths that use different directories.  No error
  will be signaled if this is violated, but it will not cooperate with
  `get-page-binding' which will only look for an `index.ss' in the same
  directory.

-------------------------------------------------------------------------------
common/layout.ss

This module defines high-level functions for creating HTML files in a uniform
format.  These are usually defined in three stages -- first, a

  (foo-page arg ...)

is defined for creating a `foo' kind of page based on some format of arguments.
These functions are usually not provided.  Then there will be two definitions
for creating such pages:

  (write-foo* filename arg ...)
  (write-foo arg ...)

The first one is a function that will use `foo-page' to create the content with
the given arguments, and write the result to `filename'.  The second one is a
syntax that uses `this-html-name' (from the expression's lexical context) for
the target file.  This module uses the Swindle language ("swindle/turbo.ss",
does not include the object system) to be able to use keyword arguments.  To
use these arguments from a conventional "common/html-script.ss"-based module,
you will need to quote the keywords, for example (foo #:bar 1).

> (write-xexpr* filename xexpr)
> (write-xexpr xexpr)

  These expect a single xexpr and write it to the target file.

> (write-raw* filename arg ...)
> (write-raw arg ...)

  These will use `concat' to append all arguments to a single string and write
  the result to the target file

> (write-redirect-page* filename url)
> (write-redirect-page url)

  Given some URL, these will create a file that automatically redirect to the
  this URL.

> (write-page* filename title [key value ...] body ...)
> (write-page title [key value ...] body ...)

  These provide basic HTML page output.  The output file will have the usual
  HTML tags, where `body ...' are Xexprs which are placed in the `<body>' tag.
  The `<head>' section of the result will have some common meta-tags, including
  tags that use `page-icon' for the icon that is used by several browsers.  The
  keywords that can be used here are
  * #:head-stuff -- a list of Xexprs that will be added to the `<head>'
    section.
  * #:extra-body-attrs -- a (list-of (list symbol string)) for additional
    attributes for the `<body>' tag.

> (write-tall-page* filename title [key value ...] body ...)
> (write-tall-page title [key value ...] body ...)

  These are used to generate almost all HTML content.  The output will have a
  title bar with a medium PLT logo on the left and a list of common hub links
  (see `hubs' above) on the right.  If the current page is one of the hub
  links, it will be shown as a simple string instead of a link.

  The body values are Xexprs, with special processing for `section' Xexprs --
  these will be transformed into section titles which have the same style and
  color of the title bar (this transformation is only for top-level Xexprs).
  Configuration keys are:

  * #:head-stuff, #:extra-body-attributes -- same as above.

  * #:color -- the color name (a symbol) for the top, bottom, and section bars;
    defaults to `default-color'.

  * #:narrow? -- if specified as #t, the header bar will be narrow.

  * #:hubs? -- can be used to disable hubs on the title bar; defaults to #t.

  * #:extra-hubs -- an optional set of hubs (in the same format as `hubs') to
    be displayed beneath the usual hubs.

  * #:footer-hubs -- an optional set of hubs to show in the footer bar.

  * #:search -- set a search mode for the search box; can be 'plt (the default)
    for searching all PLT pages, other symbols that are valid keywords for the
    PLT custom search engine (see the `search' directory), or 'results for a
    special version of the search box that appears on the search-results page.
    (Do not use #:search when #:hubs? is off.)

> (write-panel-page* filename panel title [key value ...] body ...)
> (write-panel-page panel title [key value ...] body ...)

  HTML pages that are organized in panels for navigation are generated using
  these.  Output pages will have the navigation panel on the left side of the
  screen, below a big PLT icon, and the content on the right side.  As with hub
  links, a link to the current page will be rendered as a plain string.

  The `panel' argument is a panel object that is created with `make-panel' (see
  below) -- it specifies the set of panel hubs and default attributes of the
  page that use it.  Available keys are:

  * #:head-stuff, #:extra-body-attributes, #:color, #:hubs?, #:extra-hubs --
    same as above; the default values are taken from the `panel' argument.

  * #:fake-url -- use a fake URL for the panel code.  (Needed in one rare
    case.)

> (make-panel title #:color [color #f] item ...)

  Creates a panel object, with the given default color, and the given `items'
  are the initial components of the navigation panel.  Each of these can be:

  * an Xexpr which will be used as is;

  * a list with a URL specification string as the first value and the content
    of the link text as its tail;

  * a string which is a URL specification, and the text will be the
    corresponding page's title as with `link-to'; or

  * a thunk that returns one of these values -- which is necessary to avoid
    some the circularity that will be created when a page A with a panel
    definition P refers to another page B which use `(import-from A P)' to get
    the panel object back.

> (add-to-panel panel item)

  Usually, a panel is constructed with a few initial items, and then items are
  added by `begin-panel-page' below, which uses this function to append items
  to the panel.  This will raise an exception if the panel was already used to
  generate output.

> (begin-panel-page panel filename definition ... expr ...)

  Similar to `begin-page' (see above), except that the resulting sub-page is
  also added to the given `panel'.  This makes it convenient to define a panel
  object, then add the sub-pages straight to the panel, making it unnecessary
  to maintain the list of panel item separately from the actual sub-pages.

-------------------------------------------------------------------------------
common/colors.ss

The interface to colors is using symbol names from the `colors' table.

> (color->htmlstr color)
> (color->dim-htmlstr color)
> (color->bright-htmlstr color)

  Returns an HTML color string for the given color, and its dim and bright
  variations.

> (color->big-icon color [attrs])
> (color->med-icon color [attrs])
> (color->small-icon color [attrs])

  These will return an `img' Xexpr an icon with the given color, creating the
  actual file in the right place (according to `icon-location') if this wasn't
  done yet (this uses original image files from `source-image-dir').  The
  optional `attr' argument is a list of additional attributes for the Xexpr,
  which will otherwise have only `src', `width', and `height'.

  The file name will look like "plt-<color>-<size>.jpg", except that if the
  size is the default (`default-size' which is 'big) then it will not be
  included, and if the color is the default (equal to `default-color') then
  "web" is used.  This means that we can get "plt-web.jpg" and
  "plt-web-med.jpg" (these were used for a long time, so there are probably
  pointers to these files in many places).

> (color->hgradient color [attrs])
> (color->vgradient color [attrs])

  Same as above, but for generating gradient files.

-------------------------------------------------------------------------------
common/build.ss

> distributing? (make-parameter #f)) ; copy stuff over?
> testing?      (make-parameter #f)) ; is this a temporary build?

  Both are boolean parameters.  `distributing?' is true when distribution is
  requested -- copying files to the remote destination servers etc.  `testing?'
  is true when building using a temporary root (using `-root' or `--here').
  Both are false by default.  The idea is that if both are false then we're
  building the actual content but not doing the physical file distribution.
  This can be used in rare cases where conditional output is needed -- for
  example, the "internal/htaccess.ss" avoids writing its content when testing
  since that will render previewing impossible (it refers to the password file
  that exists only on the actual server).

> (build name args)

  The main entry point for running the build.

-------------------------------------------------------------------------------
